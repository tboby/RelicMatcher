@using System.ComponentModel.DataAnnotations
@using System.Diagnostics
@using System.Timers
@using BlazorBrowserStorage
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Logging
@using RelicMatcher.Shared
@inject NavigationManager NavigationManager
@inject ILoggerProvider LoggerProvider
@inject ISessionStorage sessionStorage
@inject HttpClient Http
@implements IDisposable
@page "/relic"
<h1>Relic</h1>

@if (RelicQueueStatus == RelicQueueStatus.None || RelicQueueStatus == RelicQueueStatus.Queued)
{
    if (RelicQueueStatus == RelicQueueStatus.Queued)
    {
        <p>Currently queued for relic: @QueuedRelic.DisplayName</p>
    }
    else if (IsConnected == false)
    {
        <p>Disconnected</p>
    }
    else if (RelicQueueStatus == RelicQueueStatus.None)
    {
        <p>Not queued</p>
    }
    <EditForm Model="model" OnValidSubmit="Queue">
        <DataAnnotationsValidator />
        <ValidationSummary />

        <label>
            Include Vaulted relics:
            <input type="checkbox" @bind="IncludeVaultedRelics" />
        </label>

        <InputSelect @bind-Value="model.RelicUniqueName">
            @foreach (var cnt in FilteredRelics)
                {
                <option value="@cnt.UniqueName">@cnt.DisplayName</option>
                }
        </InputSelect>

        <InputText @bind-Value="model.User" />

        <button type="submit" disabled="@(!IsConnected)">Queue</button>
        @if (RelicQueueStatus == RelicQueueStatus.Queued)
        {
            <button @onclick="DeQueue" disabled="@(!IsConnected)">Stop queueing</button>
        }
    </EditForm>

    <dl id="relicList">
        @foreach (var relic in currentQueue)
        {
            <dt>@relic.User</dt>
            <dd>@relic.RelicDisplayName</dd>
        }
    </dl>
}
else if (RelicQueueStatus == RelicQueueStatus.PartyFound)
{
    <h3>Party found!</h3>
    <p>Relic: @CurrentParty.RelicType.DisplayName</p>
    @TimeRemaining.Seconds
    <h4>Members:</h4>
    <ul>
        @foreach (var member in CurrentParty.Members)
        {
            <li>@member.DisplayName: @member.Accepted</li>
        }
    </ul>
    <button @onclick="Accept" disabled="@(!IsConnected)">Accept</button>


}
else if (RelicQueueStatus == RelicQueueStatus.Done)
{
    <h3>Party complete!</h3>
    <p>Relic: @CurrentParty.RelicType.DisplayName</p>
    <h4>Members:</h4>
    <ul>
        @foreach (var member in CurrentParty.Members)
        {
            <li>/inv @member.DisplayName</li>
        }
    </ul>
    <button @onclick="Reset" disabled="@(!IsConnected)">Reset</button>
}


@code {
    private UserRelicQueueState UserRelicQueueState { get; set; } = UserRelicQueueState.DefaultState;
    private RelicQueueStatus RelicQueueStatus => UserRelicQueueState.RelicQueueStatus;
    private RelicType? QueuedRelic => UserRelicQueueState.RelicType;
    private Party? CurrentParty => UserRelicQueueState.Party;
    //private RelicQueueState RelicQueueState { get; set; } = RelicQueueState.None;
    private RelicQueueInput model { get; set; } = new RelicQueueInput();
    private IEnumerable<RelicType> Relics { get; set; } = new List<RelicType>();
    private IEnumerable<RelicType> FilteredRelics => Relics.Where(x => IncludeVaultedRelics || !x.Vaulted);

    private HubConnection hubConnection;
    private List<RelicQueueDisplay> currentQueue = new List<RelicQueueDisplay>();
    private bool IncludeVaultedRelics = false;

    private TimeSpan TimeRemaining => CurrentParty.DeadLine - DateTime.Now;

    //private Party currentParty;
    //private RelicType queuedRelic { get; set; }

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/relicHub"), opts => { })

            .ConfigureLogging(logging => logging.AddProvider(LoggerProvider))
            .Build();

        UserRelicQueueState = UserRelicQueueState.DefaultState;
        Relics = await Http.GetFromJsonAsync<List<RelicType>>("api/RelicData");

        var key = "userSession";
        Guid userGuid = Guid.NewGuid();
        try
        {
            userGuid = await sessionStorage.GetItem<Guid>(key);
        }
        catch (ArgumentNullException)
        {
            await sessionStorage.SetItem<Guid>(key, userGuid);
        }



        hubConnection.On<List<RelicQueueDisplay>>("ReceiveRelicQueue", (relics) =>
        {
            currentQueue = relics;
            StateHasChanged();
        });

        hubConnection.On<UserRelicQueueState>("ReceiveUserState", (userState) =>
        {
            UserRelicQueueState = userState;
            SetupTimer();
            StateHasChanged();
        });

        DeadlineTimer.Interval = 1000;
        DeadlineTimer.Elapsed += OnTimedEvent;

        await hubConnection.StartAsync();
        await ConnectUser(userGuid);

    }

    Task ConnectUser(Guid sessionUser) =>
        hubConnection.SendAsync("ConnectUser", sessionUser);

    Task Queue() =>
        hubConnection.SendAsync("QueueRelic", model);

    Task DeQueue() =>
        hubConnection.SendAsync("DeQueueRelic");

    Task Accept() =>
        hubConnection.SendAsync("AcceptAssignment");

    Task Reset() =>
        hubConnection.SendAsync("Reset");

    public bool IsConnected =>
        hubConnection.State == HubConnectionState.Connected;

    private readonly Timer DeadlineTimer = new Timer();

    private void OnTimedEvent(Object source, System.Timers.ElapsedEventArgs e)
    {
        StateHasChanged();
    }

    public void SetupTimer()
    {
        if (RelicQueueStatus == RelicQueueStatus.PartyFound)
        {
            DeadlineTimer.Start();
        }
        else
        {
            DeadlineTimer.Stop();
        }
    }

    public void Dispose()
    {
        _ = hubConnection.DisposeAsync();
    }

}
