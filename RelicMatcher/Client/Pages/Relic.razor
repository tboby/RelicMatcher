@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.SignalR.Client
@using RelicMatcher.Shared
@inject NavigationManager NavigationManager
@implements IDisposable
@page "/relic"
<h1>Relic</h1>

@if (RelicQueueState == RelicQueueState.None || RelicQueueState == RelicQueueState.Queued)
{
    if (RelicQueueState == RelicQueueState.Queued)
    {
        <p>Currently queued for relic: @queuedRelic</p>
    }
    else
    {
        <p>Not queued</p>
    }
    <EditForm Model="model" OnValidSubmit="Queue">
        <DataAnnotationsValidator />
        <ValidationSummary />

        <InputSelect @bind-Value="model.RelicType">
            @foreach (var cnt in Relics)
                {
                <option value="@cnt">@(Enum.GetName(typeof(RelicType), cnt))</option>
                }
        </InputSelect>

        <InputText @bind-Value="model.User" />

        <button type="submit" disabled="@(!IsConnected)">Queue</button>
        @if (RelicQueueState == RelicQueueState.Queued)
        {
            <button @onclick="DeQueue" disabled="@(!IsConnected)">Stop queueing</button>
        }
    </EditForm>

    <dl id="relicList">
        @foreach (var relic in currentQueue)
        {
            <dt>@relic.User</dt>
            <dd>@relic.RelicType</dd>
        }
    </dl>
}
else if (RelicQueueState == RelicQueueState.PartyFound)
{
    <h3>Party found!</h3>
    <p>Relic: @currentParty.RelicType</p>
    <h4>Members:</h4>
    <ul>
        @foreach (var member in currentParty.Members)
        {
            <li>@member.DisplayName: @member.Accepted</li>
        }
    </ul>
    <button @onclick="Accept" disabled="@(!IsConnected)">Accept</button>

}
else if (RelicQueueState == RelicQueueState.Done)
{
    <h3>Party complete!</h3>
    <p>Relic: @currentParty.RelicType</p>
    <h4>Members:</h4>
    <ul>
        @foreach (var member in currentParty.Members)
        {
            <li>/inv @member.DisplayName</li>
        }
    </ul>
    <button @onclick="Reset" disabled="@(!IsConnected)">Reset</button>
}


@code {
    private RelicQueueState RelicQueueState { get; set; } = RelicQueueState.None;
    private RelicQueueItem model { get; set; } = new RelicQueueItem();
    private IEnumerable<RelicType> Relics => new List<RelicType> { RelicType.A1, RelicType.A2, RelicType.A3 };

    private HubConnection hubConnection;
    private List<RelicQueueItem> currentQueue = new List<RelicQueueItem>();

    private Party currentParty;
    private RelicType queuedRelic { get; set; }

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/relicHub"))
            .Build();

        hubConnection.On<List<RelicQueueItem>>("ReceiveRelicQueue", (relics) =>
        {
            currentQueue = relics;
            StateHasChanged();
        });

        hubConnection.On<Party>("ReceivePartyFound", (party) =>
        {
            RelicQueueState = RelicQueueState.PartyFound;
            currentParty = party;
            StateHasChanged();
        });

        hubConnection.On<Party>("ReceivePartyStatus", (party) =>
        {
            currentParty = party;
            if (currentParty.Done)
            {
                RelicQueueState = RelicQueueState.Done;
            }
            StateHasChanged();
        });



        await hubConnection.StartAsync();
    }

    Task Queue() =>
        hubConnection.SendAsync("QueueRelic", model)
        .ContinueWith(_ =>
        {
            RelicQueueState = RelicQueueState.Queued;
            queuedRelic = model.RelicType;
        });

    Task DeQueue() =>
        hubConnection.SendAsync("DeQueueRelic")
        .ContinueWith(_ =>
        {
            RelicQueueState = RelicQueueState.None;
        });

    Task Accept() =>
        hubConnection.SendAsync("AcceptAssignment");

    Task Reset() =>
        hubConnection.SendAsync("Reset");

    public bool IsConnected =>
        hubConnection.State == HubConnectionState.Connected;

    public void Dispose()
    {
        _ = hubConnection.DisposeAsync();
    }

}
